<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JNIF: Java Native Instrumentation Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JNIF
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Java Native Instrumentation Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Java Native Instrumentation Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>JNIF is the first native Java bytecode rewriting library. JNIF is a C++ library for decoding, analyzing, editing, and encoding Java bytecode. The main benefit of JNIF is that it can be plugged into a JVMTI agent for instrumenting all classes in a JVM transparently, i.e., without connecting to another JVM and without perturbing the observed JVM. Besides, JNIF can be used in stand-alone tools as well.</p>
<p>JNIF includes a data-flow analysis for stack map generation, a complication necessary for any library that provides editing and encoding support for modern JVMs with split-time verification. It is written in C++11, in an object-oriented style similar to Java-based class rewriting APIs.</p>
<h2>Documentation</h2>
<p>The complete API documentation is available online at</p>
<p><a href="http://acuarica.bitbucket.io/jnif/">http://acuarica.bitbucket.io/jnif/</a></p>
<h2>Installation</h2>
<p>The JNIF library can be used as a static library which can be then linked with your project.</p>
<p>To compile JNIF it is enough to "make" the library:</p>
<div class="fragment"><div class="line">make</div></div><!-- fragment --><p>All sources of JNIF are contained in the <code>src</code> folder.</p>
<p>To use JNIF classes, the header file <code><a class="el" href="jnif_8hpp.html">jnif.hpp</a></code> must be included.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;jnif.hpp&gt;</div></div><!-- fragment --><p>Make sure to add the <code>src</code> folder to the include search directories so your compiler can found JNIF's headers, <em>i.e.</em>, with the <code>-I</code> compiler flag and then link your project against the <code>libjnif.a</code>.</p>
<h2>Getting started</h2>
<p>This section shows common use cases of the JNIF library, such as writing instrumentation code and analyzing class files, thus giving an overview of the library. We present the examples in an incremental fashion, adding complexity in each example.</p>
<p>In order to be able to work with class files, first they must me parsed. Given a memoery buffer with a class file and its length, the following snippet shows how to parse it.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">const char* data = ...;</div><div class="line">int len = ...;</div><div class="line"></div><div class="line">jnif::ClassFile cf(data, len);</div></div><!-- fragment --><p>JNIF's <code>ClassFile</code> class provides fields and methods for analyzing and editing a Java class. It contains the definition of each method and field declared in the Java class.</p>
<p>Once a class file is correctly parsed and loaded it can be manipulated using the methods and fields in <code>ClassFile</code>. For instance, in order to write back the parsed class file in a new buffer, the write method is used in conjunction with the <code>computeSize</code> method as shown below.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">const char* data = ...;</div><div class="line">int len = ...;</div><div class="line">jnif::ClassFile cf(data, len);</div><div class="line">int newlen = cf.computeSize();</div><div class="line">u1* newdata = new u1[newlen];</div><div class="line">cf.write(newdata, newlen);</div><div class="line"></div><div class="line">// Use newdata and newlen</div><div class="line"></div><div class="line">delete [] newdata;</div></div><!-- fragment --><p>Putting all together, the following listing shows how to read and write a class file.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">// Decode the binary data into a ClassFile object</div><div class="line">const char* data = ...;</div><div class="line">int len = ...;</div><div class="line">jnif::ClassFile cf(data, len);</div><div class="line"></div><div class="line">// Analyze or edit the ClassFile</div><div class="line">...</div><div class="line"></div><div class="line">// Encode the ClassFile into binary</div><div class="line">int newlen = cf.computeSize();</div><div class="line">u1* newdata = new u1[newlen];</div><div class="line">cf.write(newdata, newlen);</div><div class="line"></div><div class="line">// Use newdata and newlen</div><div class="line">...</div><div class="line"></div><div class="line">// Free the new binary</div><div class="line">delete [] newdata;</div></div><!-- fragment --><p>The <code>ClassFile</code> class has a collection of fields and methods which can be used to discover the members of the class file. The snippet below shows how to traverse all methods in a class to dump their names and descriptors. Note that every <code>jnif</code> class overloads the <code>operator&lt;&lt;</code> in order send it to an <code>std::ostream</code>.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">const char* data = ...;</div><div class="line">int len = ...;</div><div class="line">jnif::ClassFile cf(data, len);</div><div class="line"></div><div class="line">for (jnif::Method* m : cf.methods) {</div><div class="line">  cout &lt;&lt; &quot;Method: &quot;;</div><div class="line">  cout &lt;&lt; cf.getUtf8(m-&gt;nameIndex);</div><div class="line">  cout &lt;&lt; cf.getUtf8(m-&gt;descIndex);</div><div class="line">  cout &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>The following listing shows how to find all constructors (named <code>&lt;init&gt;</code> at Java bytecode level) in a class and how to inject instrumentation, in the form of a call to a static method <code>static void alloc(Object o)</code> of an analysis class, at the beginning of each constructor.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">ConstIndex mid = cf.addMethodRef(classIndex, &quot;alloc&quot;, &quot;(Ljava/lang/Object;)V&quot;);</div><div class="line"></div><div class="line">for (Method* method : cf.methods) {</div><div class="line">  if (method-&gt;isInit()) {</div><div class="line">    InstList&amp; instList = method-&gt;instList();</div><div class="line"></div><div class="line">    Inst* p = *instList.begin();</div><div class="line">    instList.addZero(OPCODE_aload_0, p);</div><div class="line">    instList.addInvoke(OPCODE_invokestatic, mid, p);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Another common use case is to instrument every method entry and exit. In order to do so, it is possible to add the instrumentation code at the beginning of the instruction list to detect the method entry. To detect method exit, it is necessary to look for instructions that terminate the current method execution, i.e., xRETURN family and ATHROW as showed in the following snippet.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">ConstIndex sid = cf.addMethodRef(proxyClass, &quot;enterMethod&quot;,</div><div class="line">                &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;);</div><div class="line">ConstIndex eid = cf.addMethodRef(proxyClass, &quot;exitMethod&quot;,</div><div class="line">                &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;);</div><div class="line">ConstIndex classNameIdx = cf.addStringFromClass(cf.thisClassIndex);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">InstList&amp; instList = method-&gt;instList();</div><div class="line"></div><div class="line">ConstIndex methodIndex = cf.addString(m-&gt;nameIndex);</div><div class="line"></div><div class="line">Inst* p = *instList.begin();</div><div class="line"></div><div class="line">instList.addLdc(OPCODE_ldc_w, classNameIdx, p);</div><div class="line">instList.addLdc(OPCODE_ldc_w, methodIndex, p);</div><div class="line">instList.addInvoke(OPCODE_invokestatic, sid, p);</div><div class="line"></div><div class="line">for (Inst* inst : instList) {</div><div class="line">    if (inst-&gt;isExit()) {</div><div class="line">        instList.addLdc(OPCODE_ldc_w, classNameIdx, inst);</div><div class="line">        instList.addLdc(OPCODE_ldc_w, methodIndex, inst);</div><div class="line">        instList.addInvoke(OPCODE_invokestatic, eid, inst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Besides providing access to all members of a class, <code>ClassFile</code> also provides access to the constant pool via methods like <code>getUtf8()</code> and <code>addMethodRef()</code>.</p>
<h2>Test and evaluation</h2>
<p>To run these evaluations, a Makefile script is provided in the git repository. These tasks take care of the compilation of the JNIF library and also all java files needed. The repository is self-contained, no need to download dacapo benchmarks separately.</p>
<div class="fragment"><div class="line">&gt; make testapp</div></div><!-- fragment --><p>To run a particular dacapo benchmark with default settings:</p>
<div class="fragment"><div class="line">&gt; make dacapo BENCH=avrora</div></div><!-- fragment --><p>To run a full evaluation with all dacapo benchmarks in all configuration a task -eval- is provided. You can set how many times run each configuration with the variable times, like</p>
<div class="fragment"><div class="line">&gt; make eval times=5</div></div><!-- fragment --><p>Finally, there is a task to create plots for the evaluation. This task needs R with the package ggplot2.</p>
<div class="fragment"><div class="line">&gt; make plots</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
